# Skrift Documentation

A modern Litestar-powered web application framework with multi-provider OAuth authentication, role-based access control, and WordPress-like template resolution.

For styling documentation, see: [CSS Framework](css-framework.md)
For deployment guides, see: [Deployment Guide](deployment.md)

## Table of Contents

- [Project Structure](#project-structure)
- [Quick Start](#quick-start)
- [Setup Wizard](#setup-wizard)
- [Configuration](#configuration)
- [Authentication](#authentication)
- [Role-Based Access Control](#role-based-access-control)
- [Admin Interface](#admin-interface)
- [Settings System](#settings-system)
- [Template System](#template-system)
- [Controllers & Routes](#controllers--routes)
- [Database](#database)
- [Content Management](#content-management)
- [Error Handling](#error-handling)
- [Architecture](#architecture)

## Project Structure

```
skrift/
├── skrift/
│   ├── __init__.py
│   ├── asgi.py                    # Application factory and AppDispatcher
│   ├── config.py                  # Settings and environment configuration
│   ├── cli.py                     # Database migration CLI (skrift-db)
│   ├── controllers/
│   │   ├── auth.py                # Multi-provider OAuth authentication
│   │   └── web.py                 # Main web routes (pages)
│   ├── admin/
│   │   ├── controller.py          # Admin panel routes
│   │   └── navigation.py          # Admin nav introspection
│   ├── auth/
│   │   ├── guards.py              # Permission and role guards
│   │   ├── roles.py               # Role definitions
│   │   └── services.py            # Permission lookup with caching
│   ├── db/
│   │   ├── base.py                # SQLAlchemy base model
│   │   ├── models/
│   │   │   ├── user.py            # User model
│   │   │   ├── page.py            # Page model
│   │   │   ├── role.py            # Role and permission models
│   │   │   └── setting.py         # Settings model
│   │   └── services/
│   │       ├── page_service.py    # Page CRUD operations
│   │       └── setting_service.py # Settings CRUD with caching
│   ├── lib/
│   │   ├── exceptions.py          # Custom exception handlers
│   │   └── template.py            # WordPress-like template resolver
│   └── setup/
│       ├── controller.py          # Setup wizard routes
│       ├── providers.py           # OAuth provider definitions
│       ├── config_writer.py       # app.yaml configuration management
│       ├── state.py               # Setup progress detection
│       └── middleware.py          # Setup-related middleware
├── templates/
│   ├── base.html                  # Base layout template
│   ├── index.html                 # Home page
│   ├── page.html                  # Default page template
│   ├── error.html                 # Default error template
│   ├── error-404.html             # 404 error template
│   ├── error-500.html             # 500 error template
│   ├── auth/
│   │   └── login.html             # Login page with provider buttons
│   ├── admin/
│   │   ├── admin.html             # Admin dashboard
│   │   ├── base.html              # Admin layout
│   │   ├── users/                 # User management templates
│   │   ├── pages/                 # Page management templates
│   │   └── settings/              # Site settings templates
│   └── setup/
│       ├── base.html              # Setup wizard layout
│       ├── database.html          # Database configuration step
│       ├── auth.html              # Auth providers step
│       ├── site.html              # Site settings step
│       ├── admin.html             # Admin creation step
│       └── complete.html          # Setup completion
├── alembic/
│   ├── env.py                     # Alembic environment configuration
│   ├── script.py.mako             # Migration template
│   └── versions/                  # Migration files
├── docs/
│   ├── README.md                  # This file
│   ├── css-framework.md           # CSS styling documentation
│   └── deployment.md              # Deployment guides
├── static/
│   └── css/
│       └── style.css              # Application styles
├── .env                           # Environment variables (not in git)
├── .env.example                   # Environment template
├── app.yaml                       # Application configuration (generated by setup)
├── main.py                        # Development server entry point
├── alembic.ini                    # Alembic configuration
└── pyproject.toml                 # Project dependencies
```

## Quick Start

### Prerequisites

- Python 3.13+
- [uv](https://github.com/astral-sh/uv) package manager

### Installation

1. Clone the repository and navigate to the project directory.

2. Install dependencies:
   ```bash
   uv sync
   ```

3. Create a minimal `.env` file:
   ```bash
   echo "SECRET_KEY=$(python -c 'import secrets; print(secrets.token_urlsafe(32))')" > .env
   ```

4. Run the application:
   ```bash
   uv run python main.py
   ```

5. Open http://localhost:8080 in your browser to start the setup wizard.

The setup wizard will guide you through configuring the database, authentication providers, site settings, and creating your admin account.

## Setup Wizard

Skrift includes a first-time setup wizard that guides you through initial configuration. The wizard runs automatically when the application starts without a completed configuration.

### How It Works

The application uses an **AppDispatcher** pattern that routes requests to either:
- **Setup App**: When configuration is incomplete, handles `/setup/*`, `/auth/*`, and `/static/*` routes
- **Main App**: After setup is complete, handles all normal application routes

This allows the setup wizard to run without requiring a restart after configuration.

### Setup Steps

#### Step 1: Database Configuration

Configure your database connection:

**SQLite (Development)**:
```
sqlite+aiosqlite:///./app.db
```

**PostgreSQL (Production)**:
```
postgresql+asyncpg://user:password@host:5432/dbname
```

The wizard automatically runs Alembic migrations to create the database schema.

#### Step 2: Authentication Providers

Configure one or more OAuth providers. Supported providers:

| Provider | Required Scopes | Notes |
|----------|-----------------|-------|
| Google | openid, email, profile | Standard OAuth 2.0 |
| GitHub | read:user, user:email | Special email fetching for private emails |
| Microsoft | openid, email, profile | Supports Azure AD tenant IDs |
| Discord | identify, email | Standard OAuth 2.0 |
| Facebook | email, public_profile | Standard OAuth 2.0 |
| Twitter/X | users.read, tweet.read | OAuth 2.0 with PKCE |

Each provider requires:
- **Client ID**: From the provider's developer console
- **Client Secret**: From the provider's developer console

You can use environment variable references (e.g., `$GOOGLE_CLIENT_ID`) for secrets management.

#### Step 3: Site Settings

Configure basic site information:
- **Site Name**: Displayed in the header and browser title
- **Tagline**: Site description/subtitle
- **Copyright Holder**: For footer copyright notices
- **Copyright Start Year**: Beginning year for copyright range

These settings are stored in the database and can be changed later in the admin panel.

#### Step 4: Admin Account

Create the first administrator account by logging in with one of the configured OAuth providers. The first user created during setup automatically receives the Admin role.

### Configuration File

After setup, configuration is saved to `app.yaml`:

```yaml
controllers:
  - skrift.controllers.auth:AuthController
  - skrift.admin.controller:AdminController
  - skrift.controllers.web:WebController

db:
  url: $DATABASE_URL
  pool_size: 5
  pool_overflow: 10
  pool_timeout: 30
  echo: false

auth:
  redirect_base_url: $OAUTH_REDIRECT_BASE_URL
  providers:
    google:
      client_id: $GOOGLE_CLIENT_ID
      client_secret: $GOOGLE_CLIENT_SECRET
      scopes:
        - openid
        - email
        - profile
    github:
      client_id: $GITHUB_CLIENT_ID
      client_secret: $GITHUB_CLIENT_SECRET
      scopes:
        - read:user
        - user:email
```

**Environment Variable Interpolation**: Values starting with `$` are replaced with the corresponding environment variable at runtime. This allows you to keep secrets out of the configuration file.

## Configuration

### Environment Variables

Configuration is managed via environment variables, loaded from `.env`:

| Variable | Required | Default | Description |
|----------|----------|---------|-------------|
| `SECRET_KEY` | Yes | - | Secret key for session encryption |
| `DEBUG` | No | `false` | Enable debug mode |
| `DATABASE_URL` | No | `sqlite+aiosqlite:///./app.db` | Database connection string |
| `OAUTH_REDIRECT_BASE_URL` | No | `http://localhost:8080` | Base URL for OAuth callbacks |

**OAuth Provider Variables** (configure as needed):

| Variable | Description |
|----------|-------------|
| `GOOGLE_CLIENT_ID` | Google OAuth client ID |
| `GOOGLE_CLIENT_SECRET` | Google OAuth client secret |
| `GITHUB_CLIENT_ID` | GitHub OAuth client ID |
| `GITHUB_CLIENT_SECRET` | GitHub OAuth client secret |
| `MICROSOFT_CLIENT_ID` | Microsoft OAuth client ID |
| `MICROSOFT_CLIENT_SECRET` | Microsoft OAuth client secret |
| `MICROSOFT_TENANT_ID` | Azure AD tenant ID (optional) |
| `DISCORD_CLIENT_ID` | Discord OAuth client ID |
| `DISCORD_CLIENT_SECRET` | Discord OAuth client secret |
| `FACEBOOK_CLIENT_ID` | Facebook OAuth client ID |
| `FACEBOOK_CLIENT_SECRET` | Facebook OAuth client secret |
| `TWITTER_CLIENT_ID` | Twitter/X OAuth client ID |
| `TWITTER_CLIENT_SECRET` | Twitter/X OAuth client secret |

### app.yaml Configuration

The `app.yaml` file controls application configuration:

```yaml
# Controllers to load (module.path:ClassName format)
controllers:
  - skrift.controllers.auth:AuthController
  - skrift.admin.controller:AdminController
  - skrift.controllers.web:WebController

# Database configuration
db:
  url: $DATABASE_URL           # Connection string (supports env vars)
  pool_size: 5                 # Connection pool size
  pool_overflow: 10            # Extra connections when pool is full
  pool_timeout: 30             # Seconds to wait for connection
  echo: false                  # Log SQL queries

# Authentication configuration
auth:
  redirect_base_url: http://localhost:8080
  providers:
    google:
      client_id: $GOOGLE_CLIENT_ID
      client_secret: $GOOGLE_CLIENT_SECRET
      scopes: [openid, email, profile]
```

## Authentication

### Multi-Provider OAuth

Skrift supports authentication via multiple OAuth 2.0 providers. Users can log in with any configured provider.

### OAuth Flow

1. User visits `/auth/login` and selects a provider
2. User clicks provider button, redirected to `/auth/{provider}/login`
3. CSRF state token generated and stored in session
4. User redirected to provider's consent screen
5. After consent, provider redirects to `/auth/{provider}/callback`
6. Callback handler:
   - Verifies CSRF state token
   - Exchanges authorization code for access tokens
   - Fetches user info from provider
   - Creates or updates user record
   - Sets session cookies
7. User redirected to home page

### Provider-Specific Details

**GitHub**: Requires additional API call to fetch email if user's email is private.

**Microsoft**: Supports optional `tenant_id` for Azure AD organization-specific authentication.

**Twitter/X**: Uses OAuth 2.0 with PKCE (Proof Key for Code Exchange) for enhanced security.

### Session Management

Sessions use encrypted client-side cookies:
- **Max age**: 7 days
- **Security**: HttpOnly, SameSite=Lax, Secure (in production)
- **Encryption**: AES-GCM with SHA256-hashed secret key
- **Storage**: User ID, name, email, and picture URL

### User Model

| Field | Type | Description |
|-------|------|-------------|
| `id` | UUID | Primary key (auto-generated) |
| `oauth_provider` | String | OAuth provider name |
| `oauth_id` | String | Unique ID from OAuth provider |
| `email` | String | User's email address (unique) |
| `name` | String | User's display name |
| `picture_url` | String | Profile picture URL |
| `is_active` | Boolean | Account active status |
| `last_login_at` | DateTime | Last login timestamp |
| `created_at` | DateTime | Record creation timestamp |
| `updated_at` | DateTime | Last update timestamp |

### Authentication Routes

| Method | Path | Description |
|--------|------|-------------|
| GET | `/auth/login` | Login page with provider buttons |
| GET | `/auth/logout` | Clear session and redirect to home |
| GET | `/auth/{provider}/login` | Initiate OAuth flow |
| GET | `/auth/{provider}/callback` | Handle OAuth callback |

## Role-Based Access Control

Skrift includes a flexible RBAC system for managing user permissions.

### Predefined Roles

| Role | Permissions | Description |
|------|-------------|-------------|
| Admin | `administrator` | Full system access |
| Editor | `manage-pages`, `view-drafts` | Content management |
| Author | `view-drafts` | Can view unpublished content |
| Moderator | `moderate-content` | Content moderation |

### How RBAC Works

1. **Roles** are defined in code (`skrift/auth/roles.py`) and synced to database on startup
2. **Permissions** are strings associated with roles (many-to-many)
3. **Users** can have multiple roles (many-to-many)
4. **Guards** check permissions/roles on route handlers

### Using Guards

Protect routes with permission or role requirements:

```python
from litestar import Controller, get
from skrift.auth.guards import Permission, Role, auth_guard

class ProtectedController(Controller):
    path = "/protected"
    guards = [auth_guard]  # Require authentication

    @get("/admin-only")
    @Permission("administrator")  # Require specific permission
    async def admin_only(self) -> dict:
        return {"message": "Admin access granted"}

    @get("/editor-only")
    @Role("editor")  # Require specific role
    async def editor_only(self) -> dict:
        return {"message": "Editor access granted"}
```

### Combining Requirements

Use `AndRequirement` or `OrRequirement` for complex checks:

```python
from skrift.auth.guards import Permission, OrRequirement

# User needs EITHER permission
@OrRequirement(Permission("manage-pages"), Permission("administrator"))
async def manage_content(self) -> dict:
    return {"message": "Access granted"}
```

### Permission Caching

Permissions are cached for 5 minutes to reduce database queries. The cache is invalidated when:
- User roles are modified
- Role permissions are modified
- Application restarts

## Admin Interface

The admin panel provides a web interface for managing users, pages, and site settings.

### Accessing Admin

Navigate to `/admin` after logging in with an account that has appropriate permissions.

### Admin Routes

| Path | Permission | Description |
|------|------------|-------------|
| `/admin` | Any authenticated | Admin dashboard |
| `/admin/users` | `administrator` | User management |
| `/admin/users/{id}/roles` | `administrator` | Edit user roles |
| `/admin/pages` | `manage-pages` | Page management |
| `/admin/pages/new` | `manage-pages` | Create new page |
| `/admin/pages/{id}/edit` | `manage-pages` | Edit existing page |
| `/admin/pages/{id}/publish` | `manage-pages` | Publish page |
| `/admin/pages/{id}/unpublish` | `manage-pages` | Unpublish page |
| `/admin/pages/{id}/delete` | `manage-pages` | Delete page |
| `/admin/settings` | `administrator` | Site settings |

### Dynamic Navigation

The admin navigation is built dynamically based on:
1. Available admin routes
2. User's permissions
3. Route metadata (display names, icons)

Users only see navigation items for sections they can access.

### Page Management

Create and edit pages with:
- **Slug**: URL path (e.g., `about` or `services/web`)
- **Title**: Page title
- **Content**: HTML content
- **Publication Status**: Draft or published

### User Management

Administrators can:
- View all registered users
- Assign/remove roles
- See user login history

## Settings System

Skrift includes a key-value settings system for site configuration.

### How Settings Work

Settings are stored in the `settings` database table:

| Field | Type | Description |
|-------|------|-------------|
| `key` | String | Setting name (unique) |
| `value` | Text | Setting value |

### Default Settings

| Key | Description | Default |
|-----|-------------|---------|
| `site_name` | Site name in header/title | "Skrift" |
| `site_tagline` | Site tagline/description | "" |
| `site_copyright_holder` | Copyright holder name | "" |
| `site_copyright_start_year` | Copyright start year | Current year |

### Settings Cache

Settings are cached in memory at application startup and refreshed when:
- Settings are saved in admin panel
- Application restarts

All templates automatically receive cached settings as context variables.

### Using Settings in Templates

```html
<title>{{ site_name }}</title>
<p class="tagline">{{ site_tagline }}</p>
<footer>
    &copy; {{ site_copyright_start_year }}-{{ now().year }} {{ site_copyright_holder }}
</footer>
```

## Template System

The application uses a WordPress-like template resolution system.

### How Template Resolution Works

The `Template` class resolves templates from most specific to least specific:

```python
Template("page", "services", "web")
# Tries: page-services-web.html -> page-services.html -> page.html
```

### Template Search Locations

Templates are searched in order:
1. `./templates/` (working directory - allows overrides)
2. `skrift/templates/` (package defaults)

### Template Hierarchy Examples

| URL Path | Templates Tried |
|----------|-----------------|
| `/about` | `page-about.html` -> `page.html` |
| `/services/web` | `page-services-web.html` -> `page-services.html` -> `page.html` |
| `/about/team/leadership` | `page-about-team-leadership.html` -> `page-about-team.html` -> `page-about.html` -> `page.html` |

### Template Context Variables

All templates receive:

| Variable | Type | Description |
|----------|------|-------------|
| `user` | User \| None | Current logged-in user |
| `flash` | str \| None | Flash message from session |
| `now` | callable | Function returning current datetime |
| `site_name` | str | Site name from settings |
| `site_tagline` | str | Site tagline from settings |
| `site_copyright_holder` | str | Copyright holder from settings |
| `site_copyright_start_year` | str | Copyright start year from settings |

### Base Template Blocks

The `base.html` template defines these blocks:

| Block | Purpose | Default |
|-------|---------|---------|
| `title` | Page title | Site name |
| `head` | Additional `<head>` content | Empty |
| `main_class` | Classes for `<main>` element | Empty |
| `content` | Main page content | Empty |
| `scripts` | JavaScript before `</body>` | Empty |

### Example Template

```html
{% extends "base.html" %}

{% block title %}{{ page.title }} - {{ site_name }}{% endblock %}

{% block content %}
<article>
    <h1>{{ page.title }}</h1>
    {{ page.content | safe }}
</article>
{% endblock %}
```

## Controllers & Routes

### Route Table

| Method | Path | Controller | Description |
|--------|------|------------|-------------|
| GET | `/` | WebController | Home page |
| GET | `/{path:path}` | WebController | Page from database (catch-all) |
| GET | `/auth/login` | AuthController | Login page |
| GET | `/auth/logout` | AuthController | Clear session |
| GET | `/auth/{provider}/login` | AuthController | Initiate OAuth |
| GET | `/auth/{provider}/callback` | AuthController | OAuth callback |
| GET | `/admin` | AdminController | Admin dashboard |
| GET | `/admin/users` | AdminController | User list |
| GET/POST | `/admin/users/{id}/roles` | AdminController | Edit user roles |
| GET | `/admin/pages` | AdminController | Page list |
| GET/POST | `/admin/pages/new` | AdminController | Create page |
| GET/POST | `/admin/pages/{id}/edit` | AdminController | Edit page |
| POST | `/admin/pages/{id}/publish` | AdminController | Publish page |
| POST | `/admin/pages/{id}/unpublish` | AdminController | Unpublish page |
| POST | `/admin/pages/{id}/delete` | AdminController | Delete page |
| GET/POST | `/admin/settings` | AdminController | Site settings |
| GET | `/static/*` | StaticFilesRouter | Static assets |

### Controller Configuration

Controllers are loaded dynamically from `app.yaml`:

```yaml
controllers:
  - skrift.controllers.auth:AuthController
  - skrift.admin.controller:AdminController
  - skrift.controllers.web:WebController
```

Format: `module.path:ControllerClass`

### Adding Custom Controllers

1. Create a controller:

```python
# myapp/controllers/api.py
from litestar import Controller, get

class ApiController(Controller):
    path = "/api"

    @get("/status")
    async def status(self) -> dict:
        return {"status": "ok"}
```

2. Register in `app.yaml`:

```yaml
controllers:
  - skrift.controllers.auth:AuthController
  - skrift.admin.controller:AdminController
  - myapp.controllers.api:ApiController  # Custom controller
  - skrift.controllers.web:WebController  # Keep catch-all last
```

3. Restart the application.

## Database

### Supported Databases

**SQLite (Development)**:
```
DATABASE_URL=sqlite+aiosqlite:///./app.db
```

**PostgreSQL (Production)**:
```
DATABASE_URL=postgresql+asyncpg://user:password@host:5432/dbname
```

### Database Schema

#### Users Table
Stores user authentication data. See [User Model](#user-model).

#### Pages Table

| Field | Type | Description |
|-------|------|-------------|
| `id` | UUID | Primary key |
| `slug` | String | Unique URL slug (indexed) |
| `title` | String | Page title |
| `content` | Text | HTML content |
| `is_published` | Boolean | Publication status |
| `published_at` | DateTime | Publication timestamp |
| `user_id` | UUID | Author (foreign key) |
| `created_at` | DateTime | Creation timestamp |
| `updated_at` | DateTime | Last update timestamp |

#### Roles Table

| Field | Type | Description |
|-------|------|-------------|
| `id` | UUID | Primary key |
| `name` | String | Role identifier |
| `display_name` | String | Human-readable name |
| `description` | String | Role description |

#### Role Permissions Table

| Field | Type | Description |
|-------|------|-------------|
| `id` | UUID | Primary key |
| `role_id` | UUID | Foreign key to roles |
| `permission` | String | Permission string |

#### User Roles Table (Junction)

| Field | Type | Description |
|-------|------|-------------|
| `user_id` | UUID | Foreign key to users |
| `role_id` | UUID | Foreign key to roles |

#### Settings Table

| Field | Type | Description |
|-------|------|-------------|
| `id` | UUID | Primary key |
| `key` | String | Setting name (unique) |
| `value` | Text | Setting value |

### Database Migrations

Skrift uses Alembic for database migrations.

#### Common Commands

```bash
# Apply all migrations
skrift-db upgrade head

# Show current version
skrift-db current

# Show migration history
skrift-db history

# Rollback one migration
skrift-db downgrade -1

# Generate migration from model changes
skrift-db revision --autogenerate -m "description"

# Generate SQL without executing
skrift-db upgrade head --sql
```

#### Migration Workflow

**New installation:**
```bash
skrift-db upgrade head
```

**After model changes:**
```bash
skrift-db revision --autogenerate -m "add new field"
skrift-db upgrade head
```

**Deployment:**
```bash
git pull
uv sync
skrift-db upgrade head
systemctl restart skrift
```

## Content Management

### Page Service API

The `page_service` module provides CRUD operations:

```python
from skrift.db.services import page_service

# List pages
pages = await page_service.list_pages(
    db_session,
    published_only=True,
    limit=10,
    offset=0
)

# Get page by slug
page = await page_service.get_page_by_slug(
    db_session,
    "services/web",
    published_only=True
)

# Get page by ID
page = await page_service.get_page_by_id(db_session, page_id)

# Create page
page = await page_service.create_page(
    db_session,
    slug="about",
    title="About Us",
    content="<p>Content here</p>",
    is_published=True,
    user_id=author_id
)

# Update page
page = await page_service.update_page(
    db_session,
    page_id=page_id,
    title="New Title",
    content="<p>Updated content</p>"
)

# Delete page
success = await page_service.delete_page(db_session, page_id)

# Check ownership
is_owner = await page_service.check_page_ownership(
    db_session,
    page_id,
    user_id
)
```

### Access Control

- **Anonymous users**: See only published pages
- **Authenticated users**: See all pages including drafts
- **Editors/Admins**: Can create, edit, publish, and delete pages

## Error Handling

### Content Negotiation

Error handlers detect client type and respond appropriately:
- **Browsers** (Accept: text/html): HTML error pages
- **API clients**: JSON responses

### Error Templates

Create custom error templates:
- `error-404.html` - Not Found
- `error-500.html` - Internal Server Error
- `error.html` - Default fallback

Template fallback: `error-{code}.html` -> `error.html`

### Error Context

Error templates receive:

| Variable | Type | Description |
|----------|------|-------------|
| `status_code` | int | HTTP status code |
| `message` | str | Error message |
| `user` | User \| None | Current user if authenticated |

## Architecture

### AppDispatcher Pattern

The application uses a dispatcher pattern for seamless setup/runtime switching:

```
Request
   │
   ▼
AppDispatcher
   │
   ├── Setup incomplete? ──► Setup App ──► /setup/*, /auth/*, /static/*
   │
   └── Setup complete? ────► Main App ──► All routes
```

Benefits:
- No restart required after setup
- Clean separation of setup and runtime
- Graceful transition between modes

### Request Flow

1. Request arrives at AppDispatcher
2. Dispatcher checks setup state
3. Routes to appropriate app (Setup or Main)
4. App processes request through middleware
5. Route handler executes
6. Response returned to client

### Startup Sequence

1. `create_dispatcher()` called at import
2. Check for `app.yaml` and database configuration
3. If incomplete: Create Setup App
4. If complete: Create Main App with:
   - Load controllers from `app.yaml`
   - Configure database connection
   - Set up OAuth providers
   - Initialize session management
   - Register error handlers
   - Run startup handlers (sync roles, cache settings)

### Session Architecture

- **Type**: Client-side encrypted cookies
- **Encryption**: AES-GCM with SHA256-hashed secret
- **Benefits**: Stateless, horizontally scalable
- **Stored Data**: User ID, name, email, picture URL
